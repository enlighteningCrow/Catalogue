/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package org.AOOPProject;

import java.io.File;
import java.io.FileFilter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

// import javax.swing.AbstractListModel;
// import javax.swing.JList;
// import javax.swing.JScrollPane;
import javax.swing.*;

import java.awt.*;

/**
 *
 * @author twistingcamel
 */
public class FileContentsDisplayer extends javax.swing.JPanel {
        /**
         * Creates new form FileContentsDisplayer
         */

        public FileContentsDisplayer() {
                initComponents();
        }

        /**
         * This method is called from within the constructor to initialize the
         * form. WARNING: Do NOT modify this code. The content of this method is
         * always regenerated by the Form Editor.
         */
        @SuppressWarnings("unchecked")
        // <editor-fold defaultstate="collapsed" desc="Generated
        // <editor-fold defaultstate="collapsed" desc="Generated
        // Code">//GEN-BEGIN:initComponents
        private void initComponents() {
                setLayout(new java.awt.GridBagLayout());
        }// </editor-fold>//GEN-END:initComponents

        // Additional variables
        // private File currentPath;

        /**
         * This class is used to provide a model for the file system; used as
         * 
         * Backend for the lists in ListColumnHandler
         */
        private class FileSystemModel extends AbstractListModel<File> {
                File[] files;

                public FileSystemModel(File[] files) {
                        this.files = files;
                }

                public File[] getFiles() {
                        return files;
                }

                public void setFiles(File[] files) {
                        this.files = files;
                }

                @Override
                public File getElementAt(int index) {
                        return files[index];
                }

                @Override
                public int getSize() {
                        return files.length;
                }

        }

        /**
         * The current path: eg. {home, Downloads, downloadedFile1.txt}
         */
        File[] currentFilePath;

        // -TODO: Make a class to handle a an array of JList that stores the files and
        // update them and their models
        // Note: Only one layer deeper than the currently selected file
        // (currentFilePath[currentFilePath.length - 1]) should be shown in the jLists.
        // TODO: Make a variable (setting) to store the maximum number of columns up the
        // directory that should be shown
        // TODO: manage the cursor position with shortcuts from the keyboard.
        /**
         * the maximum number of columns to show on the screen at any moment (drop down
         * lists / jLists)
         */
        private int maxColumnNumber;

        // Note: Class to handle communication between the lists in the interface and
        // the models (FileSystemModel)
        private class ListColumnsHandler {

                GridBagConstraints constraints;

                // public class ListColumn {
                // }
                /**
                 * The models for each of the columsn of ListPanes; The models[0] is for the
                 * first column (leftmost), and the models[models.size() - 1] is for the
                 * rightmost column
                 */
                public ArrayList<FileSystemModel> models;

                /**
                 * Group up the list and the pane it belongs to
                 */
                public class ListPane {
                        JList<File> list;
                        JScrollPane pane;

                        public ListPane(JList<File> list, JScrollPane pane) {
                                this.list = list;
                                this.pane = pane;
                        }
                }

                public ArrayList<ListPane> lists;

                /**
                 * Number of columns currently being shown
                 */
                private int modelsSize;

                // private ArrayList<ListColumn> li;

                /**
                 * getter for maxColumnNumber
                 * 
                 * @return max number of columns
                 */
                public int getColumnNumber() {
                        return maxColumnNumber;
                }

                /**
                 * setter for maxColumnNumber; also updates if the maxColumnNumber is changed
                 * 
                 * @param num the new maxColumnNumber
                 */
                public void setColumnNumber(int num) {
                        if (maxColumnNumber == num)
                                return;
                        maxColumnNumber = num;
                        update();
                }

                /**
                 * Constructo from max number of columns
                 * 
                 * @param num max number of columns
                 */
                public ListColumnsHandler(int num) {
                        maxColumnNumber = num;
                        update();
                }

                /**
                 * Use this function after changing the model or current path; used to update
                 * the GUI
                 */
                void update() {
                        modelsSize = Math.min(models.size(), maxColumnNumber);
                        while (lists.size() < modelsSize) {
                                ListPane item;
                                lists.add(item = new ListPane(new JList<File>(), new JScrollPane()));
                                item.pane.setViewportView(item.list);
                                constraints = new java.awt.GridBagConstraints();
                                constraints.fill = java.awt.GridBagConstraints.BOTH;
                                constraints.anchor = java.awt.GridBagConstraints.PAGE_START;
                                constraints.weightx = 1.0;
                                constraints.weighty = 1.0;
                                add(item.pane, constraints);
                        }
                        while (lists.size() > models.size()) {
                                remove(lists.get(lists.size() - 1).pane);
                                lists.remove(lists.size() - 1);
                        }
                        for (int i = 0; i < lists.size(); ++i) {
                                lists.get(i).list.setModel(models.get(i + models.size() - lists.size()));
                        }
                }
        }

        // private File[] getLeftCol() {
        // // if (currentFilePath.length == 0) {
        // // return currentFilePath[currentFilePath.length -1 ]
        // // }
        // return new File[0];
        // }

        // private File[] getMiddleCol() {
        // // return currentPath.getParentFile().listFiles();
        // return new File[0];
        // }

        // private File[] getRightCol() {
        // // return currentPath.listFiles();
        // return new File[0];
        // }

        // private FileSystemModel leftModel = new FileSystemModel(getLeftCol()),
        // middleModel = new FileSystemModel(getMiddleCol()),
        // righModel = new FileSystemModel(getRightCol());

        // private void updateMiddleModel() {
        // middleModel.setFiles(currentPath.getParentFile().listFiles());
        // }

        // TODO: (Maybe?) Change this to private/public
        /**
         * Class used to create an array of Files found from the specified paths
         */
        public class FileSystemPopulator {
                // Note: path strings with '/' separator
                String[] searchPathsRegex;
                String[] searchPathsGlob;
                ArrayList<File> contents = new ArrayList<File>();

                /**
                 * Consturctor from regex and glob patterns
                 * 
                 * @param searchPathsRegex The array of regex patterns
                 * @param searchPathsGlob  The array of glob patterns
                 */
                public FileSystemPopulator(String[] searchPathsRegex, String[] searchPathsGlob) {
                        this.searchPathsRegex = searchPathsRegex;
                        this.searchPathsGlob = searchPathsGlob;
                        update();
                }

                /**
                 * Just a getter
                 * 
                 * @return contents
                 */
                public ArrayList<File> getContents() {
                        return contents;
                }

                /**
                 * Used for filtering files with regex patterns
                 */
                static public class RegexFileFilter implements FileFilter {
                        protected Pattern pattern;

                        public Pattern getPattern() {
                                return pattern;
                        }

                        public void setPattern(Pattern pattern) {
                                this.pattern = pattern;
                        }

                        public void setPattern(String pattern) {
                                this.pattern = Pattern.compile(pattern);
                        }

                        // -TODO: check the regex part, something wrong
                        public RegexFileFilter(String pattern) {
                                try {
                                        this.pattern = Pattern.compile(pattern);
                                } catch (PatternSyntaxException e) {
                                        System.err.println(e);
                                }
                        }

                        @Override
                        public boolean accept(File pathname) {
                                return pattern.matcher(pathname.getName()).matches();
                        }

                }

                /**
                 * Used for filtering files with glob patterns
                 */
                static public class GlobFileFilter implements FileFilter {
                        PathMatcher matcher;

                        public void setGlob(String glob) {
                                this.matcher = FileSystems.getDefault().getPathMatcher(glob);
                        }

                        public GlobFileFilter(PathMatcher matcher) {
                                this.matcher = matcher;
                        }

                        public GlobFileFilter(String glob) {
                                // TODO: Fix this
                                matcher = FileSystems.getDefault().getPathMatcher("glob:" + glob);
                        }

                        @Override
                        public boolean accept(File pathname) {
                                return matcher.matches(pathname.toPath().getFileName());
                        }
                }

                /**
                 * Update the variable ${contents} using the populate function with the paths
                 * found from the search
                 * 
                 * @param <T>         The type to use (Eg. RegexFileFilter, GlobFileFilter)
                 * @param depth       The current depth of the search (recursive depth)
                 * @param searchPath  The path that is currently being searched; split into an
                 *                    array. (Eg. "/home/pi/asm" into {"/", "home", "pi", *
                 *                    "asm"})
                 * @param currentFile The current file that is currently being searched (The
                 *                    deepest file reached so far in the recursive search)
                 * @param filterType  The class of the filefilter (Eg. GlobFileFilter.class,
                 *                    RegexFileFilter.class)
                 */
                public <T extends FileFilter> void populate(int depth, String[] searchPath, File currentFile,
                                Class<T> filterType) {
                        try {
                                filterType.getConstructor(String.class);
                        } catch (Exception e) {
                                System.out.println(e);
                        }
                        if (depth == searchPath.length - 1) {
                                try {
                                        for (File i : currentFile.listFiles(
                                                        filterType.getConstructor(String.class)
                                                                        .newInstance(searchPath[depth])))
                                                contents.add(i);
                                } catch (Exception e) {
                                        System.err.println(e);
                                }
                        }

                        else if (depth < searchPath.length) {
                                try {
                                        for (File file : currentFile.listFiles(
                                                        filterType.getConstructor(String.class)
                                                                        .newInstance(searchPath[depth])))
                                                populate(depth + 1, searchPath, file, filterType);
                                } catch (Exception e) {
                                        // System.err.println(e);
                                        e.printStackTrace();
                                        System.err.println(e.getCause());
                                }
                        } else
                                throw new RuntimeException("Depth could not exceed the length of searchPath");
                }

                /**
                 * Modifies the paths strings before sending it to the populate function
                 * 
                 * @param <T>        The type to use (Eg. RegexFileFilter, GlobFileFilter)
                 * @param paths      The array of search patterns to search for corresponding to
                 *                   the filefilter provided
                 * @param filterType The class of the filefilter (Eg. GlobFileFilter.class,
                 *                   RegexFileFilter.class)
                 */
                private <T extends FileFilter> void updateS(String[] paths, Class<T> filterType) {
                        for (String searchPath : paths) {
                                String[] pathComps = searchPath.split("/");
                                if (pathComps.length == 0)
                                        throw new InvalidPathException(searchPath, "search path is empty");
                                // TODO: Check if there needs to be more hardcoded path expansions (like ~ into
                                // the home directory)
                                if (pathComps[0].equals("~")) {
                                        // TODO: Check if this is right
                                        populate(1, pathComps, new File(System.getProperty("user.home")),
                                                        filterType);
                                } else {
                                        if (pathComps[0].length() == 0)
                                                // TODO: Check if this works in Windows OS
                                                pathComps[0] = "/";
                                        populate(0, pathComps, new File(pathComps[0]), filterType);
                                }
                        }
                }

                /**
                 * Use this function after modifying the attributes to update the contents
                 * variable
                 */
                public void update() {
                        contents.clear();
                        updateS(searchPathsRegex, RegexFileFilter.class);
                        updateS(searchPathsGlob, GlobFileFilter.class);
                        contents.sort(fileSortComparator);
                }
        }

        // TODO: Change this to private/protected when done debugging
        /**
         * The file populator for the class
         */
        public FileSystemPopulator populator;
        // TODO: Make a setter function for the below variable; make it also update the
        // GUI when called.
        /**
         * The comparator used to sort the files;
         */
        public Comparator<File> fileSortComparator = new FileComparators.NameAscendingComparator();
        // -TODO: Change the below jLists; use a resizable array of them instead, such
        // that
        // there can be a variable number for columns

        // Variables declaration - do not modify//GEN-BEGIN:variables
        // End of variables declaration//GEN-END:variables

        /**
         * Constructor from a an array of regex and glob strings
         * 
         * @param fileSearchPathsRegex the regex strings array
         * @param fileSearchPathsGlob  the glob strings array
         */
        public FileContentsDisplayer(String[] fileSearchPathsRegex, String[] fileSearchPathsGlob) {
                populator = new FileSystemPopulator(fileSearchPathsRegex, fileSearchPathsGlob);
                currentFilePath = new File[0];
                initComponents();
        }

        /**
         * Constructor from a an array of glob strings
         * 
         * @param fileSearchPathsGlob the glob strings array
         */
        public FileContentsDisplayer(String[] fileSearchPathsGlob) {
                populator = new FileSystemPopulator(new String[0], fileSearchPathsGlob);
                currentFilePath = new File[0];
                initComponents();
        }

        /**
         * enum to pass to the function below; used to identify whehter aray of strings
         * passed should be interpreted as glob or regex
         */
        enum Mode {
                GLOB, REGEX
        }

        /**
         * Constructor used when only one of glob or regex is used (not both)
         * 
         * @param fileSearchPathsUnspecified An array of the glob/regex search strings
         * @param mode                       Specify whether the provided array should
         *                                   be interpreted as glob or regex
         */
        public FileContentsDisplayer(String[] fileSearchPathsUnspecified, Mode mode) {
                switch (mode) {
                        case GLOB:
                                populator = new FileSystemPopulator(new String[0], fileSearchPathsUnspecified);
                                break;
                        case REGEX:
                                populator = new FileSystemPopulator(fileSearchPathsUnspecified, new String[0]);
                                break;
                        default:
                                populator = new FileSystemPopulator(new String[0], new String[0]);
                                break;
                }
                currentFilePath = new File[0];
                initComponents();
        }

        /**
         * Creates a deep copy of this object
         * 
         * @return a deep copy of this object
         */
        public FileContentsDisplayer copy() {
                // TODO: create a method to deep copy the members of this class into a new
                // object.
                // Purpose: for splits
                // TODO: create a class inheriting JPanel that helps handle splitting in a grid
                // (like in vim's ctrl+w s/v/c) and implement a way to move between splits (like
                // in vim's ctrl+w h/j/k/l)
                return new FileContentsDisplayer();
        }
        // TODO: Make methods to navigate the tree (eg. go to parent directory, go to
        // first child directory, etc.)
        // TODO: Make methods to navigate the lists themselves (maybe add them as
        // shortcut keys, where h, j, k, l and left, down, up, right move the cursor
        // around the interface)
        // TODO: GUI: settings: paths to search: make a GUI (like vscode settings ui) to
        // edit them
        // TODO: Make a class to read the JSON
        // TODO: (Maybe) Use the File Dialog in the vscode ui to select for paths to add
        // TODO: (Continued) (Maybe) GUI: add button to insert wildcard (regex or glob)
        // TODO: Connect the leftmost buttons to the searchPathsRegex,Glob
        // TODO: Connect the upper textedit to represent the current path (pwd)
        // TODO: Make a way to edit the outer folders while making the inner folders
        // remain (in the alternative data structre (not tree, but descriptions based
        // structure))
        // TODO: Hi
        // HELLO IAIAIAIAIAIAIA
}