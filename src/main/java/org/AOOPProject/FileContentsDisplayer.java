/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package org.AOOPProject;

import java.io.File;
import java.io.FileFilter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.PathMatcher;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

// import javax.swing.AbstractListModel;
// import javax.swing.JList;
// import javax.swing.JScrollPane;
import javax.swing.*;

import java.awt.*;

/**
 *
 * @author twistingcamel
 */
public class FileContentsDisplayer extends javax.swing.JPanel {
        static Class[] strParam = { String.class };

        /**
         * Creates new form FileContentsDisplayer
         */
        public FileContentsDisplayer(String[] fileSearchPathsRegex, String[] fileSearchPathsGlob) {
                populator = new FileSystemPopulator(fileSearchPathsRegex, fileSearchPathsGlob);
                currentFilePath = new File[0];
                initComponents();
        }

        public FileContentsDisplayer(String[] fileSearchPathsGlob) {
                populator = new FileSystemPopulator(new String[0], fileSearchPathsGlob);
                currentFilePath = new File[0];
                initComponents();
        }

        enum Mode {
                GLOB, REGEX
        }

        public FileContentsDisplayer(String[] fileSearchPathsUnspecified, Mode mode) {
                switch (mode) {
                        case GLOB:
                                populator = new FileSystemPopulator(new String[0], fileSearchPathsUnspecified);
                                break;
                        case REGEX:
                                populator = new FileSystemPopulator(fileSearchPathsUnspecified, new String[0]);
                                break;
                        default:
                                populator = new FileSystemPopulator(new String[0], new String[0]);
                                break;
                }
                currentFilePath = new File[0];
                initComponents();
        }

        public FileContentsDisplayer() {
                populator = new FileSystemPopulator(new String[0], new String[0]);
                currentFilePath = new File[0];
                initComponents();
        }

        /**
         * This method is called from within the constructor to initialize the
         * form. WARNING: Do NOT modify this code. The content of this method is
         * always regenerated by the Form Editor.
         */
        @SuppressWarnings("unchecked")
        // <editor-fold defaultstate="collapsed" desc="Generated
        // <editor-fold defaultstate="collapsed" desc="Generated
        // Code">//GEN-BEGIN:initComponents
        private void initComponents() {

                setLayout(new java.awt.GridBagLayout());
        }// </editor-fold>//GEN-END:initComponents

        // Additional variables
        // private File currentPath;

        private class FileSystemModel extends AbstractListModel<File> {
                File[] files;

                public FileSystemModel(File[] files) {
                        this.files = files;
                }

                public File[] getFiles() {
                        return files;
                }

                public void setFiles(File[] files) {
                        this.files = files;
                }

                @Override
                public File getElementAt(int index) {
                        return files[index];
                }

                @Override
                public int getSize() {
                        return files.length;
                }

        }

        File[] currentFilePath;

        // TODO: Make a class to handle a an array of JList that stores the files and
        // update them and their models
        // Note: Only one layer deeper than the currently selected file
        // (currentFilePath[currentFilePath.length - 1]) should be shown in the jLists.
        // TODO: Make a variable (setting) to store the maximum number of columns up the
        // directory that should be shown
        // TODO: manage the cursor position with shortcuts from the keyboard.
        private int maxColumnNumber;

        private class ListColumnsHandler {

                GridBagConstraints constraints;

                // public class ListColumn {
                // }
                public ArrayList<FileSystemModel> models;

                public class ListPane {
                        JList<File> list;
                        JScrollPane pane;

                        public ListPane(JList<File> list, JScrollPane pane) {
                                this.list = list;
                                this.pane = pane;
                        }
                }

                public ArrayList<ListPane> lists;

                private int modelsSize;

                // private ArrayList<ListColumn> li;

                public int getColumnNumber() {
                        return maxColumnNumber;
                }

                public void setColumnNumber(int num) {
                        if (maxColumnNumber == num)
                                return;
                        maxColumnNumber = num;
                        update();
                }

                public ListColumnsHandler(int num) {
                        maxColumnNumber = num;
                        update();
                }

                void update() {
                        modelsSize = Math.min(models.size(), maxColumnNumber);
                        while (lists.size() < modelsSize) {
                                ListPane item;
                                lists.add(item = new ListPane(new JList<File>(), new JScrollPane()));
                                item.pane.setViewportView(item.list);
                                constraints = new java.awt.GridBagConstraints();
                                constraints.fill = java.awt.GridBagConstraints.BOTH;
                                constraints.anchor = java.awt.GridBagConstraints.PAGE_START;
                                constraints.weightx = 1.0;
                                constraints.weighty = 1.0;
                                add(item.pane, constraints);
                        }
                        while (lists.size() > models.size()) {
                                remove(lists.get(lists.size() - 1).pane);
                                lists.remove(lists.size() - 1);
                        }
                        for (int i = 0; i < lists.size(); ++i) {
                                lists.get(i).list.setModel(models.get(i + models.size() - lists.size()));
                        }
                }
        }

        // private File[] getLeftCol() {
        // // if (currentFilePath.length == 0) {
        // // return currentFilePath[currentFilePath.length -1 ]
        // // }
        // return new File[0];
        // }

        // private File[] getMiddleCol() {
        // // return currentPath.getParentFile().listFiles();
        // return new File[0];
        // }

        // private File[] getRightCol() {
        // // return currentPath.listFiles();
        // return new File[0];
        // }

        // private FileSystemModel leftModel = new FileSystemModel(getLeftCol()),
        // middleModel = new FileSystemModel(getMiddleCol()),
        // righModel = new FileSystemModel(getRightCol());

        // private void updateMiddleModel() {
        // middleModel.setFiles(currentPath.getParentFile().listFiles());
        // }

        private class FileSystemPopulator {
                // Note: path strings with '/' separator
                String[] searchPathsRegex;
                String[] searchPathsGlob;
                ArrayList<File> contents;

                public FileSystemPopulator(String[] searchPathsRegex, String[] searchPathsGlob) {
                        this.searchPathsRegex = searchPathsRegex;
                        this.searchPathsGlob = searchPathsGlob;
                        update();
                }

                public ArrayList<File> getContents() {
                        return contents;
                }

                static public class RegexFileFilter implements FileFilter {
                        protected Pattern pattern;

                        public Pattern getPattern() {
                                return pattern;
                        }

                        public void setPattern(Pattern pattern) {
                                this.pattern = pattern;
                        }

                        public void setPattern(String pattern) {
                                this.pattern = Pattern.compile(pattern);
                        }

                        // TODO: check the regex part, something wrong
                        public RegexFileFilter(String pattern) {
                                try {
                                        this.pattern = Pattern.compile(pattern);
                                } catch (PatternSyntaxException e) {
                                        System.err.println(e);
                                }
                        }

                        @Override
                        public boolean accept(File pathname) {
                                return pattern.matcher(pathname.getName()).matches();
                        }

                }

                static public class GlobFileFilter implements FileFilter {
                        PathMatcher matcher;

                        public void setGlob(String glob) {
                                this.matcher = FileSystems.getDefault().getPathMatcher(glob);
                        }

                        public GlobFileFilter(PathMatcher matcher) {
                                this.matcher = matcher;
                        }

                        public GlobFileFilter(String glob) {
                                // TODO: Fix this
                                matcher = FileSystems.getDefault().getPathMatcher("glob:" + glob);
                        }

                        @Override
                        public boolean accept(File pathname) {
                                return matcher.matches(pathname.toPath().getFileName());
                        }
                }

                public <T extends FileFilter> void populate(int depth, String[] searchPath, File currentFile,
                                Class<T> filterType) {
                        try {
                                filterType.getConstructor(String.class);
                        } catch (Exception e) {
                                System.out.println(e);
                        }
                        if (depth == searchPath.length - 1) {
                                try {
                                        for (File i : currentFile.listFiles(
                                                        filterType.getConstructor(String.class)
                                                                        .newInstance(searchPath[depth])))
                                                contents.add(i);
                                } catch (Exception e) {
                                        System.err.println(e);
                                }
                        }

                        else if (depth < searchPath.length) {
                                try {
                                        for (File file : currentFile.listFiles(
                                                        filterType.getConstructor(String.class)
                                                                        .newInstance(searchPath[depth])))
                                                populate(depth + 1, searchPath, file, filterType);
                                } catch (Exception e) {
                                        // System.err.println(e);
                                        e.printStackTrace();
                                        System.err.println(e.getCause());
                                }
                        } else
                                throw new RuntimeException("Depth could not exceed the length of searchPath");
                }

                private <T extends FileFilter> void updateS(String[] paths, Class<T> filterType) {
                        for (String searchPath : paths) {
                                String[] pathComps = searchPath.split("/");
                                if (pathComps.length == 0)
                                        throw new InvalidPathException(searchPath, "search path is empty");
                                if (pathComps[0].equals("~")) {
                                        // TODO: Check if this is right
                                        populate(1, pathComps, new File(System.getProperty("user.home")),
                                                        filterType);
                                } else {
                                        if (pathComps[0].length() == 0)
                                                // TODO: Check if this works in Windows OS
                                                pathComps[0] = "/";
                                        populate(0, pathComps, new File(pathComps[0]), filterType);
                                }
                        }
                }

                public void update() {
                        updateS(searchPathsRegex, RegexFileFilter.class);
                        updateS(searchPathsGlob, GlobFileFilter.class);
                }
        }

        FileSystemPopulator populator;
        // TODO: Change the below jLists; use a resizable array of them instead, such
        // that
        // there can be a variable number for columns

        // Variables declaration - do not modify//GEN-BEGIN:variables
        // End of variables declaration//GEN-END:variables
}
