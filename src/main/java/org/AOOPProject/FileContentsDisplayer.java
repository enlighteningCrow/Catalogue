/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package org.AOOPProject;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.WatchService;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.Queue;

// import javax.swing.AbstractListModel;
// import javax.swing.JList;
// import javax.swing.JScrollPane;
import javax.swing.*;

import java.awt.*;

/**
 *
 * @author twistingcamel
 */
public class FileContentsDisplayer extends javax.swing.JPanel {
	/**
	 * Creates new form FileContentsDisplayer
	 */

	public FileContentsDisplayer() {
		initComponents();
		update();
	}

	/**
	 * This method is called from within the constructor to initialize the
	 * form. WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated
	// <editor-fold defaultstate="collapsed" desc="Generated
	// <editor-fold defaultstate="collapsed" desc="Generated
	// Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		addFocusListener(new java.awt.event.FocusAdapter() {
			public void focusGained(java.awt.event.FocusEvent evt) {
				formFocusGained(evt);
			}
		});
		setLayout(new java.awt.GridBagLayout());
	}// </editor-fold>//GEN-END:initComponents

	private void formFocusGained(java.awt.event.FocusEvent evt) {// GEN-FIRST:event_formFocusGained
		// TODO Remove focus-related stuff from this class only from the netbeans
		// designer
	}// GEN-LAST:event_formFocusGained

	// Additional variables
	// private File currentPath;

	/**
	 * The current path: eg. {home, Downloads, downloadedFile1.txt}
	 */
	File[] currentFilePath;

	// -TODO: Make a class to handle a an array of JList that stores the files and
	// update them and their models
	// Note: Only one layer deeper than the currently selected file
	// (currentFilePath[currentFilePath.length - 1]) should be shown in the jLists.
	// TODO: Make a variable (setting) to store the maximum number of columns up the
	// directory that should be shown
	// TODO: manage the cursor position with shortcuts from the keyboard.
	/**
	 * the maximum number of columns to show on the screen at any moment (drop down
	 * lists / jLists)
	 */
	int maxColumnNumber;

	// private File[] getLeftCol() {
	// // if (currentFilePath.length == 0) {
	// // return currentFilePath[currentFilePath.length -1 ]
	// // }
	// return new File[0];
	// }

	// private File[] getMiddleCol() {
	// // return currentPath.getParentFile().listFiles();
	// return new File[0];
	// }

	// private File[] getRightCol() {
	// // return currentPath.listFiles();
	// return new File[0];
	// }

	// private FileSystemModel leftModel = new FileSystemModel(getLeftCol()),
	// middleModel = new FileSystemModel(getMiddleCol()),
	// righModel = new FileSystemModel(getRightCol());

	// private void updateMiddleModel() {
	// middleModel.setFiles(currentPath.getParentFile().listFiles());
	// }

	// -TODO: Change this to private/protected when done debugging
	/**
	 * The file populator for the class
	 */
	// TODO: Remove this from the class, together with all the methods involved
	public FileSystemPopulator populator = new FileSystemPopulator(this, "<Uncategorized>", "/usr/sbin");
	// TODO: Make a setter function for the below variable; make it also update the
	// GUI when called.
	/**
	 * The comparator used to sort the files;
	 */
	public Comparator<File> fileSortComparator = new FileComparators.NameAscendingComparator();
	// -TODO: Change the below jLists; use a resizable array of them instead, such
	// that
	// there can be a variable number for columns

	// Variables declaration - do not modify//GEN-BEGIN:variables
	// End of variables declaration//GEN-END:variables

	public Comparator<File> getFileSortComparator() {
		return fileSortComparator;
	}

	public void setFileSortComparator(Comparator<File> fileSortComparator) {
		this.fileSortComparator = fileSortComparator;
		populator.setComparator(this.fileSortComparator);
	}

	/**
	 * Constructor from a an array of regex and glob strings
	 * 
	 * @param fileSearchPathsRegex the regex strings array
	 * @param fileSearchPathsGlob  the glob strings array
	 */
	public FileContentsDisplayer(String categoryName, String[] fileSearchPathsRegex, String[] fileSearchPathsGlob) {
		populator = new FileSystemPopulator(this, categoryName, fileSearchPathsRegex, fileSearchPathsGlob);
		currentFilePath = new File[0];
		initComponents();
		update();
	}

	/**
	 * Constructor from a an array of glob strings
	 * 
	 * @param fileSearchPathsGlob the glob strings array
	 */
	public FileContentsDisplayer(String categoryName, String[] fileSearchPathsGlob) {
		populator = new FileSystemPopulator(this, categoryName, GlobFileFilter.class,
				fileSearchPathsGlob);
		currentFilePath = new File[0];
		initComponents();
		update();
	}

	/**
	 * enum to pass to the function below; used to identify whehter aray of strings
	 * passed should be interpreted as glob or regex
	 */
	enum Mode {
		GLOB, REGEX
	}

	/**
	 * Constructor used when only one of glob or regex is used (not both)
	 * 
	 * @param fileSearchPathsUnspecified An array of the glob/regex search strings
	 * @param mode                       Specify whether the provided array should
	 *                                   be interpreted as glob or regex
	 */
	// public FileContentsDisplayer(String[] fileSearchPathsUnspecified, Mode mode)
	// {
	// switch (mode) {
	// case GLOB:
	// populator = new FileSystemPopulator(this, new String[0],
	// fileSearchPathsUnspecified);
	// break;
	// case REGEX:
	// populator = new FileSystemPopulator(this, fileSearchPathsUnspecified, new
	// String[0]);
	// break;
	// default:
	// populator = new FileSystemPopulator(this, new String[0], new String[0]);
	// break;
	// }
	// currentFilePath = new File[0];
	// initComponents();
	// }

	ListColumnsHandler handler = new ListColumnsHandler(this, 3);

	void update() {
		bridge.update();
		populator.update();
		handler.update();
		// currentActiveDisplayer = this;
	}

	/**
	 * Creates a deep copy of this object
	 * 
	 * @return a deep copy of this object
	 */
	public FileContentsDisplayer copy() {
		// TODO: create a method to deep copy the members of this class into a new
		// object.
		// Purpose: for splits
		// TODO: create a class inheriting JPanel that helps handle splitting in a grid
		// (like in vim's ctrl+w s/v/c) and implement a way to move between splits (like
		// in vim's ctrl+w h/j/k/l)
		return new FileContentsDisplayer();
	}

	PopulatorColumnsBridge bridge = new PopulatorColumnsBridge(this);
	// WatchService service = new WatchService() {

	// };
	// Path path = Paths.get(".");
	// TODO: Use the following to watch and automatically update stuff
	WatchService watch;

	void establish() {
		try {
			watch = FileSystems.getDefault().newWatchService();
		} catch (Exception e) {

		}
	}

	public FileContentsDisplayer(File[] files) {
		initComponents();
		for (File file : files)
			bridge.addNewShownDirectory(file);
		update();
	}

	public FileContentsDisplayer(File file) {
		initComponents();
		bridge.addNewShownDirectory(file);
		update();
	}

	// public void set

	// static FileContentsDisplayer currentActiveDisplayer;
}

// TODO: Watcher for the watched paths
